input {
    udp {
        host => "0.0.0.0"
        port => "5514"
        type => "udp"
        tags => [ "pensando_flowlog" ]
    }
}

filter {
  # If the message itself is less than 99 bytes, drop it because it is an invalid message
  if [message] {
        ruby {
            code => "event.cancel if event.get('message').bytesize < 99"
        }
  }

 # Pull out the header and separate it from the CSVs
  dissect {
    mapping => { 'message' => '<%{[log][syslog_priority]}>%{[log][syslog_version]} %{[event][created]} %{[host][name]} %{[event][provider]} %{[event][provider_id]} %{[log][msg_id]} %{[log][stuctured_data]} %{csv_message}'}
  }
  split {
    field => "csv_message"
  }

  # Get the number of fields in the CSV message and store it in metadata
  ruby {
    code => "event.set('[@metadata][field_count]', event.get('csv_message').split(',').count())"
  }

  # This should be able to support 10.12.1000, 10.13.0005, 10.13.1000 and 10.14.0001 and derivatives of each branch.
  # If it has more fields than expected it will be tagged as unknown_fields and the fields will be added to the unknown_fields value
  if [@metadata][field_count] == 40
  {
    dissect {
        mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{[source][vrf_uuid]},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{[log][version]},%{[security][policy_name]},%{[security][policy_display_name]},%{[nat][src_xltd_ip]},%{[nat][dst_xltd_ip]},%{[nat][dst_xltd_port]},%{[security][encrypted]},%{[session][direction]},%{[session][create_reason]},%{[session][close_reason]},%{[source][vrf_name]},%{[destination][vrf_name]},%{[destination][vrf_uuid]},%{[destination][vlan]},%{connection_tracking},%{[source][primary_vlan]},%{[destination][primary_vlan]}'}
        add_tag => [ "aoscx_10.14.0001" ]
    }
  }
  else if [@metadata][field_count] == 38
  {
    dissect {
        mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{[source][vrf_uuid]},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{[log][version]},%{[security][policy_name]},%{[security][policy_display_name]},%{[nat][src_xltd_ip]},%{[nat][dst_xltd_ip]},%{[nat][dst_xltd_port]},%{[security][encrypted]},%{[session][direction]},%{[session][create_reason]},%{[session][close_reason]},%{[source][vrf_name]},%{[destination][vrf_name]},%{[destination][vrf_uuid]},%{[destination][vlan]},%{connection_tracking}'}
        add_tag => [ "aoscx_10.13.1000" ]
    }
  }
  else if  [@metadata][field_count] == 37
  {
    dissect {
        mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{[source][vrf_uuid]},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{[log][version]},%{[security][policy_name]},%{[security][policy_display_name]},%{[nat][src_xltd_ip]},%{[nat][dst_xltd_ip]},%{[nat][dst_xltd_port]},%{[security][encrypted]},%{[session][direction]},%{[session][create_reason]},%{[session][close_reason]},%{[source][vrf_name]},%{[destination][vrf_name]},%{[destination][vrf_uuid]},%{[destination][vlan]}' }
        add_tag => [ "aoscx_10.13.0005" ]
    }
  }
  else if  [@metadata][field_count] == 32
  {
    dissect {
        mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{[source][vrf_uuid]},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{[log][version]},%{[security][policy_name]},%{[security][policy_display_name]},%{[nat][src_xltd_ip]},%{[nat][dst_xltd_ip]},%{[nat][dst_xltd_port]},%{[security][encrypted]},%{[session][direction]},%{[session][create_reason]}' }
        add_tag => [ "aoscx_10.12.1000" ]
    }
  }
  else
  {
    dissect {
        mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{[source][vrf_uuid]},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{[log][version]},%{[security][policy_name]},%{[security][policy_display_name]},%{[nat][src_xltd_ip]},%{[nat][dst_xltd_ip]},%{[nat][dst_xltd_port]},%{[security][encrypted]},%{[session][direction]},%{[session][create_reason]},%{[session][close_reason]},%{[source][vrf_name]},%{[destination][vrf_name]},%{[destination][vrf_uuid]},%{[destination][vlan]},%{connection_tracking},%{unknown_fields}' }
        add_tag => [ "unknown_fields" ]
    }
  }

  date
  {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  mutate {
        convert => {
          "[source][port]" => "integer"
          "[destination][port]" => "integer"
          "protocol" => "integer"
          "[session][iflow_pkts]" => "integer"
          "[session][iflow_bytes]" => "integer"
          "[session][rflow_pkts]" => "integer"
          "[session][rflow_bytes]" => "integer"
          "[source][vlan]" => "integer"
          "[destination][vlan]" => "integer"
        }
      }

  ## add human readable protocol name
  if ([protocol] == 6) {
    mutate {
      add_field => {"[network][transport]" => "tcp"}
    }
  }
  else if ([protocol] == 17) {
    mutate {
      add_field => {"[network][transport]" => "udp"}
    }
  }
  else if ([protocol] == 1) {
    mutate {
      add_field => {"[network][transport]" => "icmp"}
    }
  }
  else {
    mutate {
      add_field => {"[network][transport]" => "other"}
    }
  }

  if ([connection_tracking] == "0" ) {
    mutate {
      replace  => {"[connection_tracking]" => "0"}
      add_field => {"[encrypted_tracking]" => "0"}
      add_field => {"[fragmentation_tracking]" => "0"}
    }
  }
  else if ([connection_tracking] == "1" ) {
    mutate {
      replace  => {"[connection_tracking]" => "1"}
      add_field => {"[encrypted_tracking]" => "0"}
      add_field => {"[fragmentation_tracking]" => "0"}
    }
  }
  else if ([connection_tracking] == "2") {
    mutate {
      replace  => {"[connection_tracking]" => "0"}
      add_field => {"[encrypted_tracking]" => "1"}
      add_field => {"[fragmentation_tracking]" => "0"}
    }
  }
  else if ([connection_tracking] == "3") {
    mutate {
      replace  => {"[connection_tracking]" => "1"}
      add_field => {"[encrypted_tracking]" => "1"}
      add_field => {"[fragmentation_tracking]" => "0"}
    }
  }
  else if ([connection_tracking] == "4") {
    mutate {
      replace  => {"[connection_tracking]" => "0"}
      add_field => {"[encrypted_tracking]" => "0"}
      add_field => {"[fragmentation_tracking]" => "1"}
    }
  }
  else if ([connection_tracking] == "5") {
    mutate {
      replace  => {"[connection_tracking]" => "1"}
      add_field => {"[encrypted_tracking]" => "0"}
      add_field => {"[fragmentation_tracking]" => "1"}
    }
  }
    else if ([connection_tracking] == "6") {
    mutate {
      replace  => {"[connection_tracking]" => "0"}
      add_field => {"[encrypted_tracking]" => "1"}
      add_field => {"[fragmentation_tracking]" => "1"}
    }
  }
  else {
    mutate {
      replace  => {"[connection_tracking]" => "1"}
      add_field => {"[encrypted_tracking]" => "1"}
      add_field => {"[fragmentation_tracking]" => "1"}
    }
  }



  ruby {
    code => "if event.get('[session][iflow_bytes]').nil?; event.set('[session][iflow_bytes]',0);end"
  }

  ruby {
    code => "if event.get('[session][rflow_bytes]').nil?; event.set('[session][rflow_bytes]',0);end"
  }

  ruby {
    code => "event.set('[network][bytes]',(event.get('[session][iflow_bytes]') + event.get('[session][rflow_bytes]')))"
  }

  ruby {
    code => "if event.get('[session][iflow_pkts]').nil?; event.set('[session][iflow_pkts]',0);end"
  }

  ruby {
    code => "if event.get('[session][rflow_pkts]').nil?; event.set('[session][rflow_pkts]',0);end"
  }

  ruby {
    code => "event.set('[network][packets]',(event.get('[session][iflow_pkts]') + event.get('[session][rflow_pkts]')))"
  }

  ruby {
    code => "if event.get('[source][vlan]').nil?; event.set('[source][vlan]',9999);end"
  }

  # Add application lookup based on destination port
  # Create application field with destination.port value
  mutate {
      add_field => { "[application]" => "%{[destination][port]}" }
  }

  # Rewrite application field in-place with matched application
  translate {
      source => "application"
      target => "application"
      # Dictionary file containing port to app mapping
      dictionary_path => "${DICT_FILE}"
      # "unknown" if no match
      fallback => "unknown"
  }

  # Add DNS lookup for source and destination IP
  # Copy IP fields before trying to resolve them
  mutate {
      copy => {
          "[source][ip]" => "ip.source.host.name"
          "[destination][ip]" => "ip.destination.host.name"
      }
  }
  dns {
      reverse => [ "ip.source.host.name", "ip.destination.host.name" ]
      action => "replace"
      # Store up to 131072 successful lookups
      hit_cache_size => 131072
      # Cache successful lookups for 15 minutes
      hit_cache_ttl => 900
      # Store up to 131,072 failed lookups
      failed_cache_size => 131072
      # Cache failed lookups for 15 minutes
      failed_cache_ttl => 900

      # Set timeout to prevent long-running DNS queries from blocking the pipeline
      timeout => 2.0

      # Add nameserver(s) ["10.0.0.10", "10.0.0.20"]
      nameserver => {                             
          address => ["10.29.32.11"]
      }
  }

  # Fallback for source and destination IP if DNS resolution fails
  # If DNS lookup failed, use the original IP address as the hostname value
  if ![ip.source.host.name] {
      mutate {
          replace => { "ip.source.host.name" => "%{[source][ip]}" }
      }
  }
  if ![ip.destination.host.name] {
      mutate {
          replace => { "ip.destination.host.name" => "%{[destination][ip]}" }
      }
  }

#  # Perform conversions for ECS compatibility and remove items we no longer need
#  mutate {
#      add_field => { "[ecs][version]" => "8.0.0" }
#      add_field => { "[event][kind]" => "state" }
#      add_field => { "[network][vlan]" => "%{[source][vlan]}" }
#      add_field => { "[session][total_bytes]" => "%{[network][bytes]}" }
#      add_field => { "[session][total_packets]" => "%{[network][packets]}" }
#      rename => { "message" => "[event][original]" }
#      rename => { "type" => "[log][protocol]" }
#      remove_field => [ "csv_message" ]
#      remove_field => [ "protocol" ]
#      remove_field => [ "timestamp" ]
#
#    }

  # Remove fields not need for space reasons. but no longer ECS compatibility
  mutate {
      add_field => { "[ecs][version]" => "8.0.0" }
      add_field => { "[event][kind]" => "state" }
      add_field => { "[network][vlan]" => "%{[source][vlan]}" }
      add_field => { "[session][total_bytes]" => "%{[network][bytes]}" }
      add_field => { "[session][total_packets]" => "%{[network][packets]}" }
      rename => { "type" => "[log][protocol]" }
      rename => { "message" => "[event][original]" }
      remove_field => [ "csv_message" ]
      remove_field => [ "protocol" ]
      remove_field => [ "timestamp" ]
      remove_field => [ "[event][original]" ]

    }
    

}

output {
  if [session][action] == "allow" and [session][state] == "flow_create" {
  	elasticsearch {
        hosts    => [ 'elasticsearch' ]
        index => "pensando-fwlog-create-allow-%{+YYYY.MM.dd.HH}"
    }
   }
  else if [session][action] == "deny" and [session][state] == "flow_create" {
  	elasticsearch {
        hosts    => [ 'elasticsearch' ]
        index => "pensando-fwlog-create-deny-%{+YYYY.MM.dd.HH}"
    }
   }
  else if [session][state] == "flow_delete" and [session][rflow_pkts] == 0 and [session][iflow_pkts] == 0 {
  	elasticsearch {
        hosts    => [ 'elasticsearch' ]
        index => "pensando-fwlog-empty-delete-%{+YYYY.MM.dd.HH}"
    }
   }  
  else if [session][state] != "flow_create" {
  	elasticsearch {
        hosts    => [ 'elasticsearch' ]
        index => "pensando-fwlog-session-end-%{+YYYY.MM.dd.HH}"
    }
   }
  #stdout { codec => rubydebug }
}



#output {
#  elasticsearch {
#        hosts    => [ 'elasticsearch' ]
#        index => "pensando-fwlog-%{+YYYY.MM.dd.HH}"
#    }
#
#  #stdout { codec => rubydebug }
#}
